# mysql 面试

表锁和行锁：区别就是表锁资源消耗较少，加锁快，不会出现死锁，但是锁的并发较低，不支持事务。行锁刚好相反。

表锁是myisam和InnoDB，但行锁只能是innoDB ，这两个的区别还有前者不支持外键，还有损坏的概率前者高于后者，恢复前者也比较慢



### 事务四大原则：

ACID 

原子性 ：全部成功全部失败

一致性 ：执行前后数据要保持一致

隔离性 ：并发访问时，一个事务不能被其他事务所干扰

持久性：一个事务被提交后对数据的改变是持久的



### 4大隔离级别

READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。

READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。

REPEATABLE-READ：可重复读，mysql 默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。

SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。



脏读：表示一个事务能够读取到另一个事务中还未提交的数据

不可重复读：一个事务内，多次读到的同一数据是不一样的，重点在于update和delete，要锁行


幻读：同一事务返回的结果不一样，比由于被其他事务修改了导致多次查询的结果不一致，主要是insert，要锁表



### 多版本并发控制(MVVC)

InnoDB采用的是乐观锁，所以每开启一个事务，版本号自动更新，保证了事务的安全性



### 数据库如何优化

数据库的三范式

一、数据库的每一列不可分割

二、满足第一范式，然后要有主键，最后其他属性都要完全依赖这个主键，而不是依赖其他属性

![image-20200620115727679](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200620115727679.png)

三、满足第一和第二的基础上，任何非主属性不依赖于其它非主属性

![image-20200620120120753](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200620120120753.png)

### 如何设计一个关系型数据库

存储部分：类似文件系统将数据持久化到硬盘上

创建模块部分：储存管理，缓存机制，日志管理，权限划分，容灾机制，索引管理，锁模块

### 索引

#### B 树和 B + 树的概念和区别

B树算法就是大的放右边，小的放左边，树状分布。B+树的叶子节点只有关键字key没有值value，然后指向下一个节点的索引。B树中，越靠近根节点的记录查找的时间越快，而B+树中每个记录的查找时间基本一样，都从根节点走到叶子节点，而且在叶子节点中还要再比较Key。虽然B树的性能好像比B+树好，但实际应用中是B+树。

原因：

因为B+树的叶子节点不存放实际的数据，可容纳的元素比B树多，因此树高也比B树小，这样可以减少磁盘的访问次数，查询效率稳定性更高。在访问成千上万的数据时，是巨大的优势。

对了 ，这边说下哈希索引，如果绝大数需求为单条记录查询的时候可以使用，因为查询性能最高，不然其余大部分用B数和B+数

#### 最佳左前缀法则

查询一定要从索引的最左前列开始并且不跳过索引中的列。一旦跳过某个字段，索引后面的字段将无法被使用。

#### 为什么使用索引能提高效率

数据索引的存储是有序的，通过索引查询一个数据是无需遍历的，避免每次查询都是全表扫描，大大减少了服务器需要扫描的数据行数，减少服务器的压力。

#### 什么情况下应不建或少建索引

非常小的表，非常大的表，经常插入删除修改的表，数据大量重复的表

### 索引优化

- 独立的列：索引不支持表达式

  ```sql
  SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
  ```

- 多列索引：比单列索引好，actor_id 和 film_id 设置为多列索引

  ```sql
  SELECT film_id, actor_ id FROM sakila.film_actor
  WHERE actor_id = 1 AND film_id = 1;
  ```

- 索引列的顺序：让选择性最强的索引列放在前面。

- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据

​       把相关数据保存在一起，减少了磁盘I/O。数据访问更快。

### 查询优化

Explain

1 . 系统中经常出现的sql语句如下：
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30

EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=4

EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=4 AND emp.name = ‘abcd’

解决：
**where后筛选字段有多少就建立多少索引**

CREATE INDEX idx_age_deptid_name ON emp(age,deptid,NAME)

索引优化注意点：

1.**最佳左前缀法则**

2.不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描,**在where后使用计算、函数、(自动or手动)类型转换都会使索引失效**

3.存储引擎不能使用索引中范围条件右边的列，即在建立索引时，范围查询要放到最后

4.mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描

5.is not null 也无法使用索引,但是is null是可以使用索引的

6.like以通配符开头(’%abc…’)mysql索引失效会变成全表扫描的操作

7.删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 

8.将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描

9.left join 时，选择小表作为驱动表，大表作为被驱动表

10.普通order by不能使用索引，**无过滤 不索引**，可加上过滤条件，使用索引



## 下面面试的基本题目（上面重复的就不提了）

#### **char 和 varchar 的区别是什么？**

char(n) ：固定长度类型

char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。

varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。

所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。

#### where与having的区别

* 用的地方不一样

  where可以用于select、update、delete和insert into values(select * from table where ..)语句中。

  having只能用于select语句中

* 执行的顺序不一样

  where的搜索条件是在执行语句进行分组之前应用

  having的搜索条件是在分组条件后执行的

  即如果where和having一起用时，where会先执行，having后执行

#### 如何解决事务的并发问题⭐

**1. 版本检查**

在数据库中保留“版本”字段，跟随数据同时读写，以此判断数据版本。版本可能是时间戳或状态字段。

UPDATE table SET status = 1 WHERE id=1 AND status = 0;

一般作为乐观锁使用

**2.  共享锁与排它锁**（InnoDB行锁采用的方式）

其实就是读写锁，排他锁只允许当前事务修改，而共享锁允许其他事务进行修改

**3. 悲观锁与乐观锁**

（1）悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。

一般是 where id=XX for update 来实现 （一般银行转账、工单审批） 

**悲观锁需使用数据库的锁机制实现**，如使用行级排他锁或表级排它锁。

**（2）乐观锁使用由程序逻辑控制的技术**来避免可能出现的并发问题,如版本version控制，乐观锁不能解决脏读的问题，因此仍需要数据库至少启用“读已提交”的事务隔离级别（也就是说乐观锁是需要commit的）。

### 多版本并发控制(MVCC)⭐

说白了，就是表字段里引入多个版本乐观锁进行并发控制

可以认为MVCC是行级锁的一个变种，innoDB采用了乐观锁的策略，在每行记录后保存两个隐藏列来实现，这两个列保存了行的版本号信息，每开启一个新事务，版本号自动更新，事务开始时刻的版本号作为事务的版本号。用来和查询到的记录所带的版本号进行比较来判断。

### 说一下 mysql 常用的引擎？

InnoDB和MyIsam

前面区别有说，这边提是因为很重要

InnoDB：它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。

MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。

### 聚簇索引⭐

聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据

非聚簇索引：将数据存储金和索引分开的结构，索引结构的叶子节点指向了数据的对应行

**聚簇索引具有唯一性**， 一个表仅有一个聚簇索引 。

**聚簇索引默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一的非空索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键**来作为聚簇索引。 

聚簇索引和非聚簇索引类似查字典时直接根据经验查字的大概位置和先去查偏旁部首再去翻页查询类似。

MyISAM没有聚簇索引，都是二级索引。

#### 优点

* 把相关数据保存在一起，减少了磁盘I/O。
* 数据访问更快。

### 为什么选择B+树作为索引结构⭐

B+树的优点就不说了，前面有，这边是对比几种树算法为什么 选择B+树

- **哈希索引只适用于等值查询的场景**。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描 

- 二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。
- 平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。
- 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。

## 最佳左前缀法则⭐

指的是查询从索引的最左前列开始并且不跳过索引中的列。
在创建索引的字段中第一个就是最左，每个左边的字段都是后面一个字段的一整个树，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**要按照顺序命中索引**

## sql 优化可以从哪些方面考虑？⭐

主要是从怎么**合理创建索引 合理编写 SQL 语句和防止索引失效 合理创建表字段**这3个方面入手

* **合理创建索引：**  前面那10点有说到

* **合理编写 SQL 语句：**

  不使用 select *，使用 LIMIT 语句来限制返回的数据，IN包含的值不应过多等

* **防止索引失效：**保证最左前缀法则，尽量不适用前缀模糊查询 %like，避免索引列参与计算或使用了函数，避免在where子句中对字段进行null值判断，看看表编码，表字段是否一样，联合索引中范围查询会让后面的索引字段失效，join查询时要用小表驱动大表

* **合理创建表字段：** 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库

### 性能分析的重点字段（Explain）

#### type

type显示的是访问类型 system>const>eq_ref>ref>range>index>ALL,一般来说，得保证查询至少达到range级别，最好能达到ref。 

#### Extra

包含不适合在其他列中显示但十分重要的额外信息，主要用来检测order by，group by或者关联查询是否使用了索引。

### 数据库调优经验⭐

使用了索引却仍然不是很快，就使用  explain 分析了一下发现表中有多个索引，因为可能涉及回表，排序的操作，MySQL 优化器选用了错误的索引导致查询效率偏低，然后通过 SQL 语句中使用 useindex 来指定索引解决。

我们可以考虑在读少写多的场景下（日志，账单），我们可以使用普通索引，因为innodb对普通索引做了优化，使用了 **Change buffer**，它可以把写操作缓存下来，在读的时候再去merge，这样可以减少io次数，提高语句执行速度，提高内存利用率。

### 批量往mysql导入1000万数据有什么方法？⭐

修改ENGINE=InnoDB为MyISAM（v5.1之前是MyISAM，之后是InnoDB）

减少IO次数

SQL写法优化（一条SQL语句插入多条数据）

合理设置批量大小（在事务中进行插入处理，不要一条数据提交一次，肯定要分批处理）

尽量顺序插入（减少索引的维护压力）

合并事务+事务+有序数据的优化插入方式

合理设置MySQL相应配置参数，增加缓存或减少不必要日志磁盘读写

