java基础

面向对象3大特征

封装继承多态，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。

面向过程性能比面向对象高，因为类需要实例化，开销较大，比如嵌入式开发，没有面向对象那么易于维护、扩展、复用



C++和java

java不提供指针来访问内存，所以程序内存更安全

java类是单继承，C++是多继承，但是java可以实现多个接口

java有自动内存管理机制，不需要手动释放内存



java有几种基本类型

byte short char int float double boolean long 

byte short int char float long double boolean



基本类型和引用类型的区别

基本类型直接赋值 引用类型需要new创建对象

基本类型比较的是值 所以一般用== 引用类型比较的是引用地址

引用类型的具体过程。。。。。。（需要再了解）



重载和重写

重载：发生在同一类中，方法名相同，参数类型和个数不同，顺序不同，返回值和访问修饰符可以不同

重写：方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。



说下三大特征

什么叫封装：把对象的属性和行为的代码封装在一个类，即变量和方法

java 封装，说白了就是将一大坨公共通用的实现逻辑玩意，装到一个盒子里（class），出入口都在这个盒子上。你要用就将这个盒子拿来用，连接出入口，就能用了，不用就可以直接扔，对你代码没什么影响。

对程序员来说，使用封装的目的：通俗点讲是这个

1.偷懒，辛苦一次，后面都能少敲很多代码，增强了代码得复用性

2.简化代码，看起来更容易懂

3.隐藏核心实现逻辑代码，简化外部逻辑，并且不让其他人修改，jar 都这么干

4.一对一，一个功能就只为这个功能服务；避免头发绳子一块用，导致最后一团糟

### 继承

子类继承父类的特征和行为。子类可以有父类非私有的方法，属性。子类也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高代码之间的耦合性。 

### 多态

多态是为了是程序具有更好的扩展性，并可以对类进行通用的处理。在[面向对象语言](https://baike.baidu.com/item/面向对象语言/215742)中，接口的多种不同的实现方式即为多态！

继承 重写和父类引用子类

举个例子 猫 狗 蛇都叫动物 可以表示为动物

 一般情况下 是这样的 猫 a=new  猫 多态可以表示为 动物a =new 猫 所以，可以很好用父类的一个属性



final

final修饰的类是最终类，该类不能被继承，不能被重写，不能被修改

final和finally、finanlize有什么区别

- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 

## String 为什么设置为不可变？

* 为了实现字符串常量池(只有当字符是不可变的，字符串池才有可能实现) 
* 为了线程安全(字符串自己便是线程安全的) 
* 为了保证同一个对象调用 hashCode() 都产生相同的值，String 设置为不可变可以对这个条件有很好的支持，这也是 Map 类的 key 使用 String 的原因。

string是不可修改的，操作大量数据，就不能用string，需要用到下面两个，一个是安全一个是不安全的 StringBuilder`是线程不安全的，效率较高；而`StringBuffer`是线程安全的，效率较低。



### Exception、Error、运行时异常与一般异常有何异同 /java 异常体系

**所有的异常都是从Throwable继承而来的** 

**Error**是错误，对于所有的编译时期的错误以及系统错误都是通过Error抛出的。 

 **Exception** 它规定的异常是程序本身可以处理的异常。 

**checked exception**可检查的异常，这是编码时非常常用的，所有checked exception都是需要在代码中处理的。它们的发生是可以预测的，正常的一种情况，可以合理的处理。比如IOException，或者一些自定义的异常。除了RuntimeException及其子类以外，都是checked exception。

**Unchecked Exception**

RuntimeException及其子类都是unchecked exception。比如NPE空指针异常，除数为0的算数异常ArithmeticException等等，这种异常是运行时发生，无法预先捕捉处理的。比如 NullPointerException ， SQLException， NumberFormatException ， FileNotFoundException， NoSuchMethodException。



## 接口和抽象类的区别

1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。







**总结** ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是 `==`比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。



### String s = new String(“abc”) 会创建几个对象

使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。
“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；
而使用 new 的方式会在堆中创建一个字符串对象。